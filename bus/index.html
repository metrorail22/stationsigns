</head>

<body>
  <header>
    <h1>NFTA – Live Vehicles (All Trips)</h1>
    <div class="meta" id="lastUpdated">Last update: —</div>
    <span class="pill" id="statusPill">Idle</span>

    <div class="controls">
      <button id="refreshBtn">Refresh now</button>
      <button id="selectAllBtn" title="Show all routes">Select all</button>
      <button id="clearBtn" title="Hide all routes">Clear</button>

      <label>
        Refresh (s):
        <!-- Default refresh: 20s -->
        <input id="refreshSec" type="number" min="5" max="120" value="20" />
      </label>
    </div>

    <!-- Trip counter -->
    <div class="trip-count" id="tripCount" data-count="">Trips: 0</div>
  </header>

  <div class="wrap">
    <div class="card">
      <div class="title">
        <div class="small">Map</div>
        <div class="small mono" id="debugLine"></div>
      </div>
      <div id="map"></div>
      <div class="routebar" id="routeBar">
        <span class="small">Loading routes…</span>
      </div>
    </div>

    <div class="card">
      <div class="title">
        <div class="small">Visible vehicles (filtered by selected routes)</div>
        <div class="small">From VehiclePositions feed</div>
      </div>

      <div style="max-height: 72vh; overflow:auto;">
        <table>
          <thead>
            <tr>
              <th>Route</th>
              <th>Vehicle</th>
              <th>Trip</th>
              <th class="right">Age</th>
              <th class="right">Speed</th>
              <th class="right">Bearing</th>
            </tr>
          </thead>
          <tbody id="tbody">
            <tr><td colspan="6" class="small">No data yet.</td></tr>
          </tbody>
        </table>
      </div>

      <div class="legend">
        Notes:
        <ul style="margin:8px 0 0 18px; padding:0;">
          <li>Route ↔ Vehicle association comes from the same GTFS-RT entity: <span class="mono">vehicle.trip.routeId</span> and <span class="mono">vehicle.vehicle.id</span>.</li>
          <li>Pills are built dynamically from routes seen in the feed. Click pills to filter.</li>
        </ul>
      </div>
    </div>
  </div>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>
    // === CONFIG ===
    const VEHICLE_URL_DEFAULT = "https://gtfsr.nfta.com/api/vehiclepositions?format=json";

    // === DOM ===
    const els = {
      lastUpdated: document.getElementById("lastUpdated"),
      statusPill: document.getElementById("statusPill"),
      refreshBtn: document.getElementById("refreshBtn"),
      selectAllBtn: document.getElementById("selectAllBtn"),
      clearBtn: document.getElementById("clearBtn"),
      refreshSec: document.getElementById("refreshSec"),
      debugLine: document.getElementById("debugLine"),
      routeBar: document.getElementById("routeBar"),
      tbody: document.getElementById("tbody"),
      tripCount: document.getElementById("tripCount"),
    };

    function setStatus(text, cls) {
      els.statusPill.textContent = text;
      els.statusPill.className = "pill " + (cls || "");
    }
    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
      }[c]));
    }
    function epochToLocal(sec) {
      if (!Number.isFinite(sec)) return "—";
      return new Date(sec * 1000).toLocaleTimeString([], { hour:"2-digit", minute:"2-digit", second:"2-digit" });
    }
    function ageText(tsSec) {
      if (!Number.isFinite(tsSec)) return "—";
      const now = Date.now()/1000;
      const d = Math.max(0, Math.round(now - tsSec));
      if (d < 60) return d + "s";
      const m = Math.floor(d / 60);
      const s = d % 60;
      return m + "m " + s + "s";
    }
    function mphText(mps) {
      if (!Number.isFinite(mps)) return "—";
      return (mps * 2.2369362920544).toFixed(1) + " mph";
    }

    // === ROUTE COLOR (stable hash -> HSL) ===
    function hashString(s) {
      s = String(s ?? "");
      let h = 2166136261;
      for (let i = 0; i < s.length; i++) {
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h >>> 0);
    }
    function routeColor(routeId) {
      const h = hashString(routeId) % 360;
      return `hsl(${h} 80% 55%)`;
    }

    // === MAP ===
    const map = L.map("map", { preferCanvas: true }).setView([42.8864, -78.8784], 12); // Buffalo-ish default
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "&copy; OpenStreetMap contributors"
    }).addTo(map);

    // markers keyed by stable vehicle key
    const markers = new Map(); // key -> { marker, routeId }
    const lastSeen = new Map(); // key -> epochSec

    function vehicleKey(vehicleId, tripId, entityId) {
      // Stable keying: prefer vehicleId, then tripId, then entity id
      return vehicleId || tripId || entityId || Math.random().toString(36).slice(2);
    }

    function pruneMarkers(activeKeys) {
      for (const [key, obj] of markers.entries()) {
        if (!activeKeys.has(key)) {
          map.removeLayer(obj.marker);
          markers.delete(key);
          lastSeen.delete(key);
        }
      }
    }

    // === ROUTE SELECTION STATE ===
    const routeState = {
      // routeId -> boolean selected
      selected: new Map(),
      // routeId -> count seen last refresh
      counts: new Map(),
    };

    function isRouteSelected(routeId) {
      // default behavior: if nothing selected, treat as "show all"
      const any = Array.from(routeState.selected.values()).some(Boolean);
      if (!any) return true;
      return !!routeState.selected.get(routeId);
    }

    function setAllRoutesSelected(val) {
      for (const r of routeState.selected.keys()) routeState.selected.set(r, val);
      renderRoutePills();
    }

    function toggleRoute(routeId) {
      const cur = !!routeState.selected.get(routeId);
      routeState.selected.set(routeId, !cur);
      renderRoutePills();
    }

    function renderRoutePills() {
      const routes = Array.from(routeState.counts.keys()).sort((a,b) => String(a).localeCompare(String(b), undefined, { numeric:true, sensitivity:"base" }));
      if (!routes.length) {
        els.routeBar.innerHTML = `<span class="small">No routes yet.</span>`;
        return;
      }

      const anySelected = Array.from(routeState.selected.values()).some(Boolean);
      const help = anySelected
        ? `<span class="small">Showing selected routes only</span>`
        : `<span class="small">No routes selected → showing ALL routes</span>`;

      els.routeBar.innerHTML = routes.map(r => {
        const pressed = !!routeState.selected.get(r);
        const count = routeState.counts.get(r) || 0;
        const color = routeColor(r);
        return `
          <button class="route-pill" type="button" data-route="${escapeHtml(r)}" aria-pressed="${pressed ? "true":"false"}" title="Toggle route ${escapeHtml(r)}">
            <span class="dot" style="background:${color}"></span>
            <span class="mono">${escapeHtml(r)}</span>
            <span class="small">(${count})</span>
          </button>
        `;
      }).join("") + `<span style="margin-left:auto;">${help}</span>`;

      // wire click handlers
      els.routeBar.querySelectorAll("button.route-pill").forEach(btn => {
        btn.addEventListener("click", () => {
          const r = btn.getAttribute("data-route");
          toggleRoute(r);
          // re-apply current data without refetch (markers already built for last refresh)
          applyVisibilityToExistingMarkers();
          applyTableVisibility();
        });
      });
    }

    // We keep the last refresh rows so toggling pills updates instantly
    let lastRows = [];

    function applyVisibilityToExistingMarkers() {
      for (const [key, obj] of markers.entries()) {
        const show = isRouteSelected(obj.routeId);
        if (show) {
          if (!map.hasLayer(obj.marker)) obj.marker.addTo(map);
        } else {
          if (map.hasLayer(obj.marker)) map.removeLayer(obj.marker);
        }
      }
    }

    function applyTableVisibility() {
      const visible = lastRows.filter(r => isRouteSelected(r.routeId));
      if (!visible.length) {
        els.tbody.innerHTML = `<tr><td colspan="6" class="small">No vehicles match your selected routes (or no vehicles in feed).</td></tr>`;
        return;
      }

      // Sort for readability: route, then vehicle
      visible.sort((a,b) => {
        const ra = String(a.routeId), rb = String(b.routeId);
        const c = ra.localeCompare(rb, undefined, { numeric:true, sensitivity:"base" });
        if (c) return c;
        return String(a.vehicleId).localeCompare(String(b.vehicleId), undefined, { numeric:true, sensitivity:"base" });
      });

      els.tbody.innerHTML = visible.map(r => `
        <tr>
          <td class="mono">
            <span class="dot" style="background:${routeColor(r.routeId)}; margin-right:8px; vertical-align:middle;"></span>
            ${escapeHtml(r.routeId)}
          </td>
          <td class="mono">${escapeHtml(r.vehicleId)}</td>
          <td class="mono">${escapeHtml(r.tripId)}</td>
          <td class="right mono" title="Timestamp: ${escapeHtml(epochToLocal(r.ts))}">${escapeHtml(ageText(r.ts))}</td>
          <td class="right mono">${escapeHtml(mphText(r.speedMps))}</td>
          <td class="right mono">${Number.isFinite(r.bearing) ? escapeHtml(r.bearing.toFixed(0) + "°") : "—"}</td>
        </tr>
      `).join("");
    }

    function markerIcon(routeId) {
      const c = routeColor(routeId);
      // Simple divIcon with colored dot
      return L.divIcon({
        className: "",
        html: `<div style="
          width:14px;height:14px;border-radius:999px;
          background:${c};
          border:2px solid rgba(255,255,255,.7);
          box-shadow: 0 0 0 2px rgba(0,0,0,.35);
        "></div>`,
        iconSize: [14,14],
        iconAnchor: [7,7],
      });
    }

    function updateTripCountBlink(totalTrips) {
      const prev = parseInt(els.tripCount.dataset.count || "-1", 10);

      els.tripCount.textContent = `Trips: ${totalTrips}`;
      els.tripCount.dataset.count = String(totalTrips);

      // Blink only when it changes (not on first load)
      if (prev !== -1 && prev !== totalTrips) {
        els.tripCount.classList.remove("blink");
        void els.tripCount.offsetWidth; // force reflow to restart animation
        els.tripCount.classList.add("blink");
      }
    }

    async function refresh() {
      const vehicleUrl = VEHICLE_URL_DEFAULT;

      els.refreshBtn.disabled = true;
      setStatus("Loading…", "warn");
      const t0 = performance.now();

      try {
        const resp = await fetch(vehicleUrl, { cache: "no-store" });
        if (!resp.ok) throw new Error(`VehiclePositions HTTP ${resp.status}`);

        const data = await resp.json();
        const entities = Array.isArray(data?.entity) ? data.entity : [];

        // rebuild counts each refresh
        routeState.counts.clear();

        const activeKeys = new Set();
        const rows = [];

        for (const e of entities) {
          const v = e?.vehicle;
          if (!v) continue;

          const trip = v?.trip || {};
          const routeId = (trip?.routeId ?? trip?.route_id ?? "—");
          const tripId  = (trip?.tripId ?? trip?.trip_id ?? "—");

          // position required to plot
          const pos = v?.position || {};
          const lat = pos?.latitude;
          const lon = pos?.longitude;
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;

          const vehicleId =
            v?.vehicle?.id ||
            v?.vehicle?.label ||
            v?.vehicle?.licensePlate ||
            "—";

          const ts = Number.isFinite(v?.timestamp) ? v.timestamp : Math.floor(Date.now()/1000);

          // counts for pills
          routeState.counts.set(routeId, (routeState.counts.get(routeId) || 0) + 1);

          // ensure selection map has key (do not auto-select; default empty => show all)
          if (!routeState.selected.has(routeId)) routeState.selected.set(routeId, false);

          const key = vehicleKey(vehicleId, tripId, e?.id);
          activeKeys.add(key);
          lastSeen.set(key, ts);

          const speedMps = Number.isFinite(pos?.speed) ? pos.speed : null;
          const bearing  = Number.isFinite(pos?.bearing) ? pos.bearing : null;

          const popup = `
            <div class="mono">
              <div><b>Route:</b> ${escapeHtml(routeId)}</div>
              <div><b>Vehicle:</b> ${escapeHtml(vehicleId)}</div>
              <div><b>Trip:</b> ${escapeHtml(tripId)}</div>
              <div><b>Time:</b> ${escapeHtml(epochToLocal(ts))} (${escapeHtml(ageText(ts))} ago)</div>
              <div><b>Speed:</b> ${escapeHtml(mphText(speedMps))}</div>
              <div><b>Bearing:</b> ${Number.isFinite(bearing) ? escapeHtml(bearing.toFixed(0) + "°") : "—"}</div>
              <div><b>Lat/Lon:</b> ${lat.toFixed(6)}, ${lon.toFixed(6)}</div>
            </div>
          `;

          if (!markers.has(key)) {
            const m = L.marker([lat, lon], { icon: markerIcon(routeId) }).bindPopup(popup);
            markers.set(key, { marker: m, routeId });
          } else {
            const obj = markers.get(key);
            obj.routeId = routeId; // route can change
            obj.marker.setLatLng([lat, lon]);
            obj.marker.setPopupContent(popup);
            obj.marker.setIcon(markerIcon(routeId));
          }

          rows.push({ key, routeId, vehicleId, tripId, lat, lon, ts, speedMps, bearing });
        }

        pruneMarkers(activeKeys);

        // Save rows for pill toggling without refetch
        lastRows = rows;

        // Render pills (keeps prior selection states)
        renderRoutePills();

        // Apply marker visibility based on current pill selection
        applyVisibilityToExistingMarkers();

        // Render table rows based on selection
        applyTableVisibility();

        // Update trip count (blinks on change)
        updateTripCountBlink(rows.length);

        // Fit to visible markers (if any)
        const visiblePts = [];
        for (const r of lastRows) {
          if (!isRouteSelected(r.routeId)) continue;
          visiblePts.push([r.lat, r.lon]);
        }
        if (visiblePts.length) {
          map.fitBounds(L.latLngBounds(visiblePts).pad(0.2), { animate: true, duration: 0.5 });
        }

        const t1 = performance.now();
        els.lastUpdated.textContent = `Last update: ${new Date().toLocaleString()}`;
        els.debugLine.textContent = `Fetched ${entities.length} entities • plotted ${rows.length} • ${Math.round(t1 - t0)}ms`;
        setStatus("OK", "ok");
      } catch (err) {
        els.tbody.innerHTML = `<tr><td colspan="6" class="small">Error: ${escapeHtml(err?.message || String(err))}</td></tr>`;
        setStatus("Error", "err");
        els.debugLine.textContent =
          "If you see a CORS error in DevTools, serve this from a web server (not file://) or proxy the feed through your server.";
      } finally {
        els.refreshBtn.disabled = false;
      }
    }

    // === REFRESH TIMER CONTROL ===
    let timer = null;
    function setTimerFromUI() {
      const sec = Math.max(5, Math.min(120, parseInt(els.refreshSec.value || "20", 10)));
      els.refreshSec.value = String(sec);
      if (timer) clearInterval(timer);
      timer = setInterval(refresh, sec * 1000);
    }

    // === EVENTS ===
    els.refreshBtn.addEventListener("click", refresh);

    els.selectAllBtn.addEventListener("click", () => {
      setAllRoutesSelected(true);
      applyVisibilityToExistingMarkers();
      applyTableVisibility();
    });

    els.clearBtn.addEventListener("click", () => {
      setAllRoutesSelected(false);
      applyVisibilityToExistingMarkers();
      applyTableVisibility();
    });

    els.refreshSec.addEventListener("change", () => {
      setTimerFromUI();
    });

    // Start
    setTimerFromUI();
    refresh();
  </script>
</body>
</html>
